#!/bin/bash
export GOOGLE_APPLICATION_CREDENTIALS="/home/judex/nanopi-key.json"

# Configuración de cámara
RTSP_USER="admin"
RTSP_PASS="Filianore.1"
RTSP_PORT="554"
RTSP_PATH="/cam/realmonitor?channel=1&subtype=1"
ENV_FILE="/etc/camera_ip.env"

# Configuración de almacenamiento
BUCKET_NAME="nanopi-videos-input" # Bucket fijo para todos los dispositivos
SEGMENT_TIME=20
LOCAL_DIR="/tmp/camera_segments"
PENDING_DIR="/tmp/camera_segments/pending"
LOG_FILE="/var/log/camera-capture.log"

# Obtener el ID de hardware único (MAC address de eth0 sin los dos puntos)
HW_ID=$(cat /sys/class/net/eth0/address | tr -d ':')
if [ -z "$HW_ID" ]; then
    log "ERROR: No se pudo obtener la dirección MAC de eth0. Usando 'unknown_device' como ID."
    HW_ID="unknown_device"
fi

# Crear directorios
mkdir -p "$LOCAL_DIR"
mkdir -p "$PENDING_DIR"

# Función de logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Función para cargar la IP de la cámara
load_camera_ip() {
    if [ -f "$ENV_FILE" ]; then
        source "$ENV_FILE"
        if [ -n "$CAMERA_IP" ]; then
            return 0
        fi
    fi
    return 1
}

# Función para construir URL RTSP
get_camera_url() {
    if [ -n "$CAMERA_IP" ]; then
        echo "rtsp://${RTSP_USER}:${RTSP_PASS}@${CAMERA_IP}:${RTSP_PORT}${RTSP_PATH}"
    else
        echo ""
    fi
}

# Función para verificar si la cámara sigue accesible
test_camera_connection() {
    local URL=$(get_camera_url)
    if [ -z "$URL" ]; then
        return 1
    fi

    timeout 3 ffprobe -v quiet -rtsp_transport tcp -i "$URL" 2>/dev/null
    return $?
}

# Función para ejecutar el scanner
run_scanner() {
    log "Ejecutando scanner de cámara..."
    if /root/scan_camera.sh; then
        load_camera_ip
        return 0
    else
        return 1
    fi
}

# Función para subir archivos pendientes en background
upload_pending_files() {
    # Construir la ruta de destino usando el ID de Hardware
    local DESTINATION_PATH="gs://${BUCKET_NAME}/${HW_ID}/"
    log "[UPLOADER] Usando ID de hardware: ${HW_ID}"
    log "[UPLOADER] Usando ruta de destino: ${DESTINATION_PATH}"

    while true; do
        for PENDING_FILE in $(ls -1tr "$PENDING_DIR"/*.mp4 2>/dev/null); do
            if [ -f "$PENDING_FILE" ]; then
                BASENAME=$(basename "$PENDING_FILE")
                log "[UPLOADER] Intentando subir: $BASENAME"
                # Usar la ruta de destino con el ID de hardware
                if /opt/google-cloud-sdk/bin/gsutil cp "$PENDING_FILE" "$DESTINATION_PATH" >> "$LOG_FILE" 2>&1; then
                    log "[UPLOADER] ✓ Subida exitosa: $BASENAME"
                    rm "$PENDING_FILE"
                else
                    log "[UPLOADER] ✗ Fallo en subida: $BASENAME (reintentará en 10s)"
                    break
                fi
            fi
        done
        sleep 5
    done
}

log "========================================="
log "Iniciando servicio de captura de video"
log "Bucket: gs://$BUCKET_NAME/${HW_ID}/"
log "Duración por segmento: ${SEGMENT_TIME}s"
log "========================================="
log "Esperando estabilización de red (10s)..."
sleep 10

# --- INICIO DE BLOQUE DE PRUEBA GCP ---
log "[GCP CHECK] Probando conexión con Google Cloud Storage..."
if /opt/google-cloud-sdk/bin/gsutil -q ls "gs://${BUCKET_NAME}/"; then
    log "[GCP CHECK] ✓ Conexión con GCP exitosa."
else
    log "[GCP CHECK] ✗ ERROR: No se pudo conectar a gs://${BUCKET_NAME}/"
    log "[GCP CHECK] Verifique la autenticación (GOOGLE_APPLICATION_CREDENTIALS) o la conexión a internet."
    # Si prefieres que el script falle aquí, descomenta la siguiente línea:
    # exit 1
fi
# --- FIN DE BLOQUE DE PRUEBA GCP ---


# Cargar IP de la cámara o ejecutar scanner
if ! load_camera_ip; then
    log "No se encontró IP de cámara guardada"
    if ! run_scanner; then
        log "ERROR: No se pudo encontrar la cámara"
        exit 1
    fi
fi

CAMERA_URL=$(get_camera_url)
log "Cámara configurada: ${CAMERA_IP}"
log "URL: rtsp://${RTSP_USER}:***@${CAMERA_IP}:${RTSP_PORT}${RTSP_PATH}"

# Iniciar proceso de subida en background
upload_pending_files &
UPLOADER_PID=$!
log "Proceso de subida iniciado (PID: $UPLOADER_PID)"

# Contador de errores consecutivos
ERROR_COUNT=0
MAX_ERRORS=3

# Captura continua
while true; do
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    FILENAME="${LOCAL_DIR}/video_${TIMESTAMP}.mp4"

    log "[CAPTURE] Iniciando captura: video_${TIMESTAMP}.mp4"

    # Capturar video
    ffmpeg -rtsp_transport tcp \
           -i "$CAMERA_URL" \
           -t $SEGMENT_TIME \
           -c:v copy \
           -an \
           -f mp4 \
           -movflags +faststart \
           -y "$FILENAME" 2>&1 | grep -E "(error|Error|frame=)" | tail -5 >> "$LOG_FILE"

    if [ -f "$FILENAME" ]; then
        FILE_SIZE=$(stat -c%s "$FILENAME" 2>/dev/null)

        # Verificar que el archivo tenga contenido válido
        if [ "$FILE_SIZE" -gt 1000 ]; then
            log "[CAPTURE] ✓ Archivo creado: ${FILE_SIZE} bytes"
            mv "$FILENAME" "$PENDING_DIR/"
            log "[CAPTURE] → Archivo movido a cola de subida"
            ERROR_COUNT=0  # Reset contador de errores
        else
            log "[CAPTURE] ✗ Archivo muy pequeño, posible error de captura"
            rm "$FILENAME" 2>/dev/null
            ERROR_COUNT=$((ERROR_COUNT + 1))
        fi
    else
        log "[CAPTURE] ✗ ERROR: No se pudo capturar el segmento"
        ERROR_COUNT=$((ERROR_COUNT + 1))
    fi

    # Si hay muchos errores consecutivos, intentar reconectar
    if [ $ERROR_COUNT -ge $MAX_ERRORS ]; then
        log "[RECONNECT] Detectados $ERROR_COUNT errores consecutivos"
        log "[RECONNECT] Verificando conexión con cámara..."

        if ! test_camera_connection; then
            log "[RECONNECT] ✗ Cámara no responde - Ejecutando scanner..."

            if run_scanner; then
                CAMERA_URL=$(get_camera_url)
                log "[RECONNECT] ✓ Nueva IP encontrada: $CAMERA_IP"
                ERROR_COUNT=0
            else
                log "[RECONNECT] ✗ No se pudo encontrar la cámara"
                log "[RECONNECT] Reintentando en 30 segundos..."
                sleep 30
            fi
        else
            log "[RECONNECT] ✓ Cámara responde, continuando..."
            ERROR_COUNT=0
        fi

        sleep 2
    fi
done